#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "esp_log.h"
#include "esp_system.h"
#include "esp_wifi.h"
#include "esp_netif.h"
#include "esp_event.h"
#include "esp_http_server.h"
#include "nvs_flash.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"
#include "freertos/event_groups.h"
#include "cJSON.h"
#include "esp_vfs.h"
#include "esp_vfs_fat.h"
#include "web_controller.h"

// å®šä¹‰MINå®?å¦‚æœæœªå®šä¹?
#ifndef MIN
#define MIN(a, b) (((a) < (b)) ? (a) : (b))
#endif

static const char *TAG = "WEB_CONTROLLER";

// WiFiè¿æ¥äº‹ä»¶ç»„æ ‡å¿—ä½
#define WIFI_CONNECTED_BIT BIT0
#define WIFI_FAIL_BIT      BIT1

// é»˜è®¤HTTPç«¯å£
#define DEFAULT_HTTP_PORT 80

// å†…ç½®HTMLé¡µé¢å¤§å°
#define MAX_HTML_SIZE 15000  // 15KB

// ç½‘é¡µæ§åˆ¶å™¨ç»“æ„ä½“å®šä¹‰
struct web_controller {
    robotic_arm_handle_t *arm;          // æœºæ¢°è‡‚å¥æŸ?
    learning_handle_t *learning;        // å­¦ä¹ æ§åˆ¶å™¨å¥æŸ?
    EventGroupHandle_t wifi_event_group; // WiFiäº‹ä»¶ç»?
    bool ap_mode;                       // WiFiæ¨¡å¼
    char ip_addr[16];                   // IPåœ°å€
    httpd_handle_t server;              // HTTPæœåŠ¡å™¨å¥æŸ?
    char *html_content;                 // HTMLé¡µé¢å†…å®¹
    SemaphoreHandle_t json_mutex;       // JSONæ“ä½œäº’æ–¥é”?
};

// å‡½æ•°å‰å‘å£°æ˜
// WiFiäº‹ä»¶å¤„ç†å‡½æ•°å·²ç§»åŠ¨åˆ°wifi_handlers.c
extern void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data);
extern esp_err_t init_wifi_ap(struct web_controller *controller);
extern esp_err_t init_wifi_sta(struct web_controller *handle, const char *ssid, const char *password);

static esp_err_t init_http_server(struct web_controller *handle);
static char *generate_html_content(void);
static esp_err_t init_spiffs(void);

// HTTPè¯·æ±‚å¤„ç†å‡½æ•°
static esp_err_t index_handler(httpd_req_t *req)
{
    struct web_controller *controller = req->user_ctx;
    
    // ä»SPIFFSè¯»å–HTMLæ–‡ä»¶
    FILE* f = fopen("/spiffs/index.html", "r");
    if (f == NULL) {
        ESP_LOGE(TAG, "æ— æ³•æ‰“å¼€index.htmlæ–‡ä»¶");
        httpd_resp_send_500(req);
        return ESP_FAIL;
    }
    
    // è·å–æ–‡ä»¶å¤§å°
    fseek(f, 0, SEEK_END);
    long fsize = ftell(f);
    fseek(f, 0, SEEK_SET);
    
    // åˆ†é…å†…å­˜å¹¶è¯»å–æ–‡ä»?
    char *buffer = malloc(fsize + 1);
    if (buffer == NULL) {
        ESP_LOGE(TAG, "å†…å­˜åˆ†é…å¤±è´¥");
        fclose(f);
        httpd_resp_send_500(req);
        return ESP_FAIL;
    }
    
    size_t read_size = fread(buffer, 1, fsize, f);
    fclose(f);
    
    if (read_size != fsize) {
        ESP_LOGE(TAG, "è¯»å–æ–‡ä»¶å¤±è´¥");
        free(buffer);
        httpd_resp_send_500(req);
        return ESP_FAIL;
    }
    
    buffer[fsize] = '\0';
    
    // å‘é€HTMLå†…å®¹
    httpd_resp_set_type(req, "text/html");
    httpd_resp_send(req, buffer, fsize);
    
    free(buffer);
    return ESP_OK;
}

// è·å–æœºæ¢°è‡‚çŠ¶æ€API
static esp_err_t arm_status_handler(httpd_req_t *req)
{
    struct web_controller *controller = req->user_ctx;
    cJSON *response = cJSON_CreateObject();
    
    xSemaphoreTake(controller->json_mutex, portMAX_DELAY);
    
    // è·å–å½“å‰è§’åº¦ - ä½¿ç”¨æ§åˆ¶å™¨ä¸­å­˜å‚¨çš„å½“å‰è§’åº?
    robotic_arm_angles_t angles = controller->arm->current_angles;
    
    cJSON_AddNumberToObject(response, "base", angles.base);
    cJSON_AddNumberToObject(response, "shoulder", angles.shoulder);
    cJSON_AddNumberToObject(response, "elbow", angles.elbow);
    cJSON_AddNumberToObject(response, "wrist", angles.wrist);
    cJSON_AddNumberToObject(response, "gripper", angles.gripper);
    
    // è·å–å­¦ä¹ æ§åˆ¶å™¨æ¨¡å¼?
    learning_mode_t mode = learning_get_mode(controller->learning);
    cJSON_AddNumberToObject(response, "mode", (int)mode);
    
    // åºåˆ—åŒ–JSONå¹¶å‘é€?
    char *json_str = cJSON_PrintUnformatted(response);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, json_str);
    
    free(json_str);
    cJSON_Delete(response);
    xSemaphoreGive(controller->json_mutex);
    
    return ESP_OK;
}

// æ§åˆ¶æœºæ¢°è‡‚å…³èŠ‚API
static esp_err_t arm_control_handler(httpd_req_t *req)
{
    struct web_controller *controller = req->user_ctx;
    char content[100];
    size_t recv_size = MIN(req->content_len, sizeof(content) - 1);
    
    int ret = httpd_req_recv(req, content, recv_size);
    if (ret <= 0) {
        if (ret == HTTPD_SOCK_ERR_TIMEOUT) {
            httpd_resp_send_408(req);
        }
        return ESP_FAIL;
    }
    content[ret] = '\0';
    
    xSemaphoreTake(controller->json_mutex, portMAX_DELAY);
    
    cJSON *root = cJSON_Parse(content);
    cJSON *response = cJSON_CreateObject();
    bool success = false;
    
    if (root != NULL) {
        robotic_arm_angles_t angles;
        bool has_angles = false;
        int joint_idx = -1;
        float angle = 0;
        
        // æ£€æŸ¥æ˜¯å•å…³èŠ‚æ§åˆ¶è¿˜æ˜¯å¤šå…³èŠ‚æ§åˆ¶
        cJSON *joint = cJSON_GetObjectItem(root, "joint");
        cJSON *angle_item = cJSON_GetObjectItem(root, "angle");
        
        if (joint && angle_item && cJSON_IsNumber(joint) && cJSON_IsNumber(angle_item)) {
            // å•å…³èŠ‚æ§åˆ?
            joint_idx = joint->valueint;
            angle = angle_item->valuedouble;
            
            esp_err_t ret = ESP_OK;
            if (joint_idx >= 0 && joint_idx < ROBOTIC_ARM_MAX_SERVOS) {
                ret = robotic_arm_set_joint_angle(controller->arm, joint_idx, angle, true, 30);
                success = (ret == ESP_OK);
            }
        } else {
            // å¤šå…³èŠ‚æ§åˆ?
            cJSON *base = cJSON_GetObjectItem(root, "base");
            cJSON *shoulder = cJSON_GetObjectItem(root, "shoulder");
            cJSON *elbow = cJSON_GetObjectItem(root, "elbow");
            cJSON *wrist = cJSON_GetObjectItem(root, "wrist");
            cJSON *gripper = cJSON_GetObjectItem(root, "gripper");
            
            // è·å–å½“å‰è§’åº¦
            angles = controller->arm->current_angles;
            
            if (base && cJSON_IsNumber(base)) {
                angles.base = base->valuedouble;
                has_angles = true;
            }
            
            if (shoulder && cJSON_IsNumber(shoulder)) {
                angles.shoulder = shoulder->valuedouble;
                has_angles = true;
            }
            
            if (elbow && cJSON_IsNumber(elbow)) {
                angles.elbow = elbow->valuedouble;
                has_angles = true;
            }
            
            if (wrist && cJSON_IsNumber(wrist)) {
                angles.wrist = wrist->valuedouble;
                has_angles = true;
            }
            
            if (gripper && cJSON_IsNumber(gripper)) {
                angles.gripper = gripper->valuedouble;
                has_angles = true;
            }
            
            if (has_angles) {
                esp_err_t ret = robotic_arm_set_angles(controller->arm, &angles, true, 30);
                success = (ret == ESP_OK);
            }
        }
        
        cJSON_Delete(root);
    }
    
    cJSON_AddBoolToObject(response, "success", success);
    char *json_str = cJSON_PrintUnformatted(response);
    
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, json_str);
    
    free(json_str);
    cJSON_Delete(response);
    xSemaphoreGive(controller->json_mutex);
    
    return ESP_OK;
}

// å­¦ä¹ æ§åˆ¶ç›¸å…³API
static esp_err_t learning_control_handler(httpd_req_t *req)
{
    struct web_controller *controller = req->user_ctx;
    char content[100];
    size_t recv_size = MIN(req->content_len, sizeof(content) - 1);
    
    int ret = httpd_req_recv(req, content, recv_size);
    if (ret <= 0) {
        if (ret == HTTPD_SOCK_ERR_TIMEOUT) {
            httpd_resp_send_408(req);
        }
        return ESP_FAIL;
    }
    content[ret] = '\0';
    
    xSemaphoreTake(controller->json_mutex, portMAX_DELAY);
    
    cJSON *root = cJSON_Parse(content);
    cJSON *response = cJSON_CreateObject();
    bool success = false;
    char message[64] = "æ“ä½œå¤±è´¥";
    
    if (root != NULL) {
        cJSON *action = cJSON_GetObjectItem(root, "action");
        cJSON *path_idx_item = cJSON_GetObjectItem(root, "path_index");
        
        int path_idx = 0;
        if (path_idx_item && cJSON_IsNumber(path_idx_item)) {
            path_idx = path_idx_item->valueint;
        }
        
        if (action && cJSON_IsString(action)) {
            const char *action_str = action->valuestring;
            
            if (strcmp(action_str, "set_mode") == 0) {
                cJSON *mode_item = cJSON_GetObjectItem(root, "mode");
                if (mode_item && cJSON_IsNumber(mode_item)) {
                    int mode = mode_item->valueint;
                    if (mode >= 0 && mode < LEARNING_MODE_MAX) {
                        esp_err_t err = learning_set_mode(controller->learning, (learning_mode_t)mode);
                        if (err == ESP_OK) {
                            success = true;
                            snprintf(message, sizeof(message), "è®¾ç½®æ¨¡å¼æˆåŠŸ: %d", mode);
                        }
                    }
                }
            } else if (strcmp(action_str, "start_recording") == 0) {
                esp_err_t err = learning_start_recording(controller->learning);
                if (err == ESP_OK) {
                    success = true;
                    strcpy(message, "å¼€å§‹è®°å½?);
                }
            } else if (strcmp(action_str, "stop_recording") == 0) {
                esp_err_t err = learning_stop_recording(controller->learning);
                if (err == ESP_OK) {
                    success = true;
                    strcpy(message, "åœæ­¢è®°å½•");
                }
            } else if (strcmp(action_str, "save_path") == 0) {
                esp_err_t err = learning_save_path(controller->learning, path_idx);
                if (err == ESP_OK) {
                    success = true;
                    snprintf(message, sizeof(message), "ä¿å­˜è·¯å¾„ %d æˆåŠŸ", path_idx);
                }
            } else if (strcmp(action_str, "load_path") == 0) {
                esp_err_t err = learning_load_path(controller->learning, path_idx);
                if (err == ESP_OK) {
                    success = true;
                    snprintf(message, sizeof(message), "åŠ è½½è·¯å¾„ %d æˆåŠŸ", path_idx);
                }
            } else if (strcmp(action_str, "delete_path") == 0) {
                esp_err_t err = learning_delete_path(controller->learning, path_idx);
                if (err == ESP_OK) {
                    success = true;
                    snprintf(message, sizeof(message), "åˆ é™¤è·¯å¾„ %d æˆåŠŸ", path_idx);
                }
            } else if (strcmp(action_str, "start_playback") == 0) {
                esp_err_t err = learning_start_playback(controller->learning, path_idx);
                if (err == ESP_OK) {
                    success = true;
                    snprintf(message, sizeof(message), "å¼€å§‹å›æ”¾è·¯å¾?%d", path_idx);
                }
            } else if (strcmp(action_str, "stop_playback") == 0) {
                esp_err_t err = learning_stop_playback(controller->learning);
                if (err == ESP_OK) {
                    success = true;
                    strcpy(message, "åœæ­¢å›æ”¾");
                }
            }
        }
        
        cJSON_Delete(root);
    }
    
    cJSON_AddBoolToObject(response, "success", success);
    cJSON_AddStringToObject(response, "message", message);
    
    char *json_str = cJSON_PrintUnformatted(response);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, json_str);
    
    free(json_str);
    cJSON_Delete(response);
    xSemaphoreGive(controller->json_mutex);
    
    return ESP_OK;
}

// ä¸‹è½½è·¯å¾„æ–‡ä»¶
static esp_err_t download_path_handler(httpd_req_t *req)
{
    struct web_controller *controller = req->user_ctx;
    char path_index_str[5];
    
    // è·å–URLæŸ¥è¯¢å‚æ•°
    if (httpd_req_get_url_query_str(req, path_index_str, sizeof(path_index_str)) != ESP_OK) {
        httpd_resp_send_404(req);
        return ESP_FAIL;
    }
    
    char param[5];
    if (httpd_query_key_value(path_index_str, "idx", param, sizeof(param)) != ESP_OK) {
        httpd_resp_send_404(req);
        return ESP_FAIL;
    }
    
    int path_index = atoi(param);
    if (path_index < 0 || path_index >= LEARNING_MAX_PATHS) {
        httpd_resp_send_404(req);
        return ESP_FAIL;
    }
    
    xSemaphoreTake(controller->json_mutex, portMAX_DELAY);
    
    // åŠ è½½è·¯å¾„
    robot_path_t path;
    memset(&path, 0, sizeof(robot_path_t));
    
    esp_err_t err = learning_load_path(controller->learning, path_index);
    if (err != ESP_OK) {
        xSemaphoreGive(controller->json_mutex);
        httpd_resp_send_404(req);
        return ESP_FAIL;
    }
    
    // åˆ¶ä½œè·¯å¾„çš„JSONè¡¨ç¤º
    cJSON *root = cJSON_CreateObject();
    cJSON *points_array = cJSON_CreateArray();
    
    cJSON_AddNumberToObject(root, "path_index", path_index);
    cJSON_AddNumberToObject(root, "point_count", controller->learning->current_path.point_count);
    cJSON_AddNumberToObject(root, "total_time_ms", controller->learning->current_path.total_time_ms);
    
    for (int i = 0; i < controller->learning->current_path.point_count; i++) {
        path_point_t *point = &controller->learning->current_path.points[i];
        cJSON *point_obj = cJSON_CreateObject();
        
        cJSON_AddNumberToObject(point_obj, "timestamp", point->timestamp);
        
        cJSON *angles = cJSON_CreateObject();
        cJSON_AddNumberToObject(angles, "base", point->angles.base);
        cJSON_AddNumberToObject(angles, "shoulder", point->angles.shoulder);
        cJSON_AddNumberToObject(angles, "elbow", point->angles.elbow);
        cJSON_AddNumberToObject(angles, "wrist", point->angles.wrist);
        cJSON_AddNumberToObject(angles, "gripper", point->angles.gripper);
        
        cJSON_AddItemToObject(point_obj, "angles", angles);
        cJSON_AddItemToArray(points_array, point_obj);
    }
    
    cJSON_AddItemToObject(root, "points", points_array);
    
    char *json_str = cJSON_PrintUnformatted(root);
    size_t json_len = strlen(json_str);
    
    // è®¾ç½®å“åº”å¤?
    httpd_resp_set_type(req, "application/json");
    char attachment[40];
    snprintf(attachment, sizeof(attachment), "attachment; filename=path_%d.json", path_index);
    httpd_resp_set_hdr(req, "Content-Disposition", attachment);
    
    // å‘é€JSONæ–‡ä»¶
    httpd_resp_send(req, json_str, json_len);
    
    free(json_str);
    cJSON_Delete(root);
    xSemaphoreGive(controller->json_mutex);
    
    return ESP_OK;
}

// ä¸Šä¼ è·¯å¾„æ–‡ä»¶
static esp_err_t upload_path_handler(httpd_req_t *req)
{
    struct web_controller *controller = req->user_ctx;
    char content[4096]; // å‡è®¾è·¯å¾„æ–‡ä»¶ä¸ä¼šè¶…è¿‡4KB
    
    // æ¥æ”¶å†…å®¹
    int received = 0;
    int remaining = req->content_len;
    if (remaining > sizeof(content) - 1) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "å†…å®¹å¤ªå¤§");
        return ESP_FAIL;
    }
    
    while (remaining > 0) {
        int recv_len = httpd_req_recv(req, content + received, remaining);
        if (recv_len <= 0) {
            if (recv_len == HTTPD_SOCK_ERR_TIMEOUT) {
                continue; // è¶…æ—¶ï¼Œç»§ç»­å°è¯?
            }
            httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "æ¥æ”¶å¤±è´¥");
            return ESP_FAIL;
        }
        received += recv_len;
        remaining -= recv_len;
    }
    content[received] = '\0';
    
    xSemaphoreTake(controller->json_mutex, portMAX_DELAY);
    
    cJSON *root = cJSON_Parse(content);
    cJSON *response = cJSON_CreateObject();
    bool success = false;
    
    if (root != NULL) {
        cJSON *path_index_item = cJSON_GetObjectItem(root, "path_index");
        cJSON *points_array = cJSON_GetObjectItem(root, "points");
        
        if (path_index_item && cJSON_IsNumber(path_index_item) &&
            points_array && cJSON_IsArray(points_array)) {
            
            int path_index = path_index_item->valueint;
            if (path_index >= 0 && path_index < LEARNING_MAX_PATHS) {
                
                robot_path_t new_path;
                memset(&new_path, 0, sizeof(robot_path_t));
                
                int point_count = cJSON_GetArraySize(points_array);
                if (point_count > LEARNING_MAX_PATH_POINTS) {
                    point_count = LEARNING_MAX_PATH_POINTS;
                }
                
                new_path.point_count = point_count;
                
                for (int i = 0; i < point_count; i++) {
                    cJSON *point_obj = cJSON_GetArrayItem(points_array, i);
                    if (point_obj) {
                        cJSON *timestamp = cJSON_GetObjectItem(point_obj, "timestamp");
                        cJSON *angles = cJSON_GetObjectItem(point_obj, "angles");
                        
                        if (timestamp && cJSON_IsNumber(timestamp) && angles) {
                            path_point_t *point = &new_path.points[i];
                            point->timestamp = timestamp->valueint;
                            
                            cJSON *base = cJSON_GetObjectItem(angles, "base");
                            cJSON *shoulder = cJSON_GetObjectItem(angles, "shoulder");
                            cJSON *elbow = cJSON_GetObjectItem(angles, "elbow");
                            cJSON *wrist = cJSON_GetObjectItem(angles, "wrist");
                            cJSON *gripper = cJSON_GetObjectItem(angles, "gripper");
                            
                            if (base && cJSON_IsNumber(base)) {
                                point->angles.base = base->valuedouble;
                            }
                            
                            if (shoulder && cJSON_IsNumber(shoulder)) {
                                point->angles.shoulder = shoulder->valuedouble;
                            }
                            
                            if (elbow && cJSON_IsNumber(elbow)) {
                                point->angles.elbow = elbow->valuedouble;
                            }
                            
                            if (wrist && cJSON_IsNumber(wrist)) {
                                point->angles.wrist = wrist->valuedouble;
                            }
                            
                            if (gripper && cJSON_IsNumber(gripper)) {
                                point->angles.gripper = gripper->valuedouble;
                            }
                        }
                    }
                }
                
                // è®¾ç½®è·¯å¾„æ€»æ—¶é—?
                if (point_count > 0) {
                    new_path.total_time_ms = new_path.points[point_count - 1].timestamp;
                }
                
                // å¤åˆ¶åˆ°å½“å‰è·¯å¾?
                memcpy(&controller->learning->current_path, &new_path, sizeof(robot_path_t));
                
                // ä¿å­˜è·¯å¾„
                esp_err_t err = learning_save_path(controller->learning, path_index);
                if (err == ESP_OK) {
                    success = true;
                }
            }
        }
        
        cJSON_Delete(root);
    }
    
    cJSON_AddBoolToObject(response, "success", success);
    char *json_str = cJSON_PrintUnformatted(response);
    
    httpd_resp_set_type(req, "application/json");
    httpd_resp_send(req, json_str, strlen(json_str));
    
    free(json_str);
    cJSON_Delete(response);
    xSemaphoreGive(controller->json_mutex);
    
    return ESP_OK;
}

// åˆå§‹åŒ–SPIFFSæ–‡ä»¶ç³»ç»Ÿ
static esp_err_t init_spiffs(void)
{
    ESP_LOGI(TAG, "åˆå§‹åŒ–æ–‡ä»¶ç³»ç»?);
    
    // é…ç½®FATæ–‡ä»¶ç³»ç»Ÿ
    esp_vfs_fat_mount_config_t mount_config = {
        .max_files = 5,
        .format_if_mount_failed = true,
        .allocation_unit_size = CONFIG_WL_SECTOR_SIZE
    };
    
    wl_handle_t wl_handle;
    esp_err_t ret = esp_vfs_fat_spiflash_mount("/spiffs", "www", &mount_config, &wl_handle);
    
    if (ret != ESP_OK) {
        if (ret == ESP_FAIL) {
            ESP_LOGE(TAG, "æ— æ³•æŒ‚è½½æˆ–æ ¼å¼åŒ–æ–‡ä»¶ç³»ç»Ÿ");
        } else if (ret == ESP_ERR_NOT_FOUND) {
            ESP_LOGE(TAG, "æ‰¾ä¸åˆ°æŒ‡å®šçš„åˆ†åŒº");
        } else {
            ESP_LOGE(TAG, "åˆå§‹åŒ–æ–‡ä»¶ç³»ç»Ÿå¤±è´? %s", esp_err_to_name(ret));
        }
        return ret;
    }
    
    ESP_LOGI(TAG, "æ–‡ä»¶ç³»ç»ŸæŒ‚è½½æˆåŠŸ");
    return ESP_OK;
}

// ç”ŸæˆHTMLå†…å®¹ - ä»…ä½œä¸ºå¤‡ç”¨ï¼Œç°åœ¨ä¸»è¦ä»SPIFFSè¯»å–
static char *generate_html_content(void)
{
    char *html = malloc(MAX_HTML_SIZE);
    if (!html) {
        ESP_LOGE(TAG, "æ— æ³•åˆ†é…HTMLå†…å­˜");
        return NULL;
    }
    
    // ä½¿ç”¨æœ€å°çš„HTMLå†…å®¹ï¼Œä½œä¸ºå¤‡ç”?
    strcpy(html, "<html><body><h1>ESP32 Robot Arm</h1><p>Error loading web interface from SPIFFS.</p></body></html>");
    
    return html;
}

// åˆå§‹åŒ–HTTPæœåŠ¡å™?
static esp_err_t init_http_server(struct web_controller *handle)
{
    httpd_config_t config = HTTPD_DEFAULT_CONFIG();
    config.server_port = DEFAULT_HTTP_PORT;
    config.lru_purge_enable = true;
    
    // å¯åŠ¨HTTPæœåŠ¡å™?
    ESP_LOGI(TAG, "å¯åŠ¨HTTPæœåŠ¡å™¨ï¼Œç«¯å£:%d", config.server_port);
    
    esp_err_t ret = httpd_start(&handle->server, &config);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "å¯åŠ¨HTTPæœåŠ¡å™¨å¤±è´? %d", ret);
        return ret;
    }
    
    // æ³¨å†ŒURIå¤„ç†å‡½æ•°
    httpd_uri_t index_uri = {
        .uri       = "/",
        .method    = HTTP_GET,
        .handler   = index_handler,
        .user_ctx  = handle
    };
    httpd_register_uri_handler(handle->server, &index_uri);
    
    httpd_uri_t arm_status_uri = {
        .uri       = "/api/status",
        .method    = HTTP_GET,
        .handler   = arm_status_handler,
        .user_ctx  = handle
    };
    httpd_register_uri_handler(handle->server, &arm_status_uri);
    
    httpd_uri_t arm_control_uri = {
        .uri       = "/api/control",
        .method    = HTTP_POST,
        .handler   = arm_control_handler,
        .user_ctx  = handle
    };
    httpd_register_uri_handler(handle->server, &arm_control_uri);
    
    httpd_uri_t learning_control_uri = {
        .uri       = "/api/learning",
        .method    = HTTP_POST,
        .handler   = learning_control_handler,
        .user_ctx  = handle
    };
    httpd_register_uri_handler(handle->server, &learning_control_uri);
    
    httpd_uri_t download_path_uri = {
        .uri       = "/api/download_path",
        .method    = HTTP_GET,
        .handler   = download_path_handler,
        .user_ctx  = handle
    };
    httpd_register_uri_handler(handle->server, &download_path_uri);
    
    httpd_uri_t upload_path_uri = {
        .uri       = "/api/upload_path",
        .method    = HTTP_POST,
        .handler   = upload_path_handler,
        .user_ctx  = handle
    };
    httpd_register_uri_handler(handle->server, &upload_path_uri);
    
    ESP_LOGI(TAG, "HTTPæœåŠ¡å™¨å·²å¯åŠ¨ï¼Œè¯·è®¿é—®: http://%s/", handle->ip_addr);
    
    return ESP_OK;
}

// åˆå§‹åŒ–ç½‘é¡µæ§åˆ¶å™¨
esp_err_t web_controller_init(const web_controller_config_t *config, web_controller_handle_t *handle)
{
    if (!config || !handle || !config->arm || !config->learning) {
        return ESP_ERR_INVALID_ARG;
    }
    
    // åˆ†é…æ§åˆ¶å™¨ç»“æ„ä½“å†…å­˜
    struct web_controller *controller = calloc(1, sizeof(struct web_controller));
    if (!controller) {
        ESP_LOGE(TAG, "åˆ†é…å†…å­˜å¤±è´¥");
        return ESP_ERR_NO_MEM;
    }
    
    controller->arm = config->arm;
    controller->learning = config->learning;
    controller->ap_mode = config->ap_mode;
    controller->wifi_event_group = xEventGroupCreate();
    
    // åˆ›å»ºäº’æ–¥é”?
    controller->json_mutex = xSemaphoreCreateMutex();
    if (!controller->json_mutex) {
        ESP_LOGE(TAG, "åˆ›å»ºäº’æ–¥é”å¤±è´?);
        free(controller);
        return ESP_ERR_NO_MEM;
    }
    
    // åˆå§‹åŒ–SPIFFSæ–‡ä»¶ç³»ç»Ÿ
    esp_err_t ret = init_spiffs();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "åˆå§‹åŒ–SPIFFSå¤±è´¥");
        // ç»§ç»­æ‰§è¡Œï¼Œä½¿ç”¨å¤‡ç”¨HTMLå†…å®¹
    }
    
    // ç”ŸæˆHTMLå†…å®¹
    controller->html_content = generate_html_content();
    if (!controller->html_content) {
        ESP_LOGE(TAG, "ç”ŸæˆHTMLå†…å®¹å¤±è´¥");
        vSemaphoreDelete(controller->json_mutex);
        free(controller);
        return ESP_ERR_NO_MEM;
    }
    
    *handle = controller;
    return ESP_OK;
}

// å¯åŠ¨ç½‘é¡µæ§åˆ¶å™?
esp_err_t web_controller_start(web_controller_handle_t handle)
{
    if (!handle) {
        return ESP_ERR_INVALID_ARG;
    }
    
    struct web_controller *controller = (struct web_controller *)handle;
    
    // åˆå§‹åŒ–ESP-NETIF
    ESP_ERROR_CHECK(esp_netif_init());
    
    // åˆ›å»ºé»˜è®¤äº‹ä»¶å¾ªç¯
    ESP_ERROR_CHECK(esp_event_loop_create_default());
    
    // åˆ›å»ºWiFi STAæˆ–APæ¥å£
    if (controller->ap_mode) {
        esp_netif_create_default_wifi_ap();
    } else {
        esp_netif_create_default_wifi_sta();
    }
    
    // åˆå§‹åŒ–WiFi
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&cfg));
    
    // æ³¨å†ŒWiFiäº‹ä»¶å¤„ç†å‡½æ•°
    esp_event_handler_instance_t instance_any_id;
    esp_event_handler_instance_t instance_got_ip;
    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,
                                                       ESP_EVENT_ANY_ID,
                                                       &wifi_event_handler,
                                                       controller,
                                                       &instance_any_id));
    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT,
                                                       IP_EVENT_STA_GOT_IP,
                                                       &wifi_event_handler,
                                                       controller,
                                                       &instance_got_ip));
    
    esp_err_t ret = ESP_OK;
    
    // å¯åŠ¨WiFi
    if (controller->ap_mode) {
        ret = init_wifi_ap(controller);
    } else {
        ret = init_wifi_sta(controller, "your_ssid", "your_password");
    }
    
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "å¯åŠ¨WiFiå¤±è´¥: %d", ret);
        return ret;
    }
    
    // å¯åŠ¨HTTPæœåŠ¡å™?
    ret = init_http_server(controller);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "å¯åŠ¨HTTPæœåŠ¡å™¨å¤±è´? %d", ret);
        return ret;
    }
    
    return ESP_OK;
}

// åœæ­¢ç½‘é¡µæ§åˆ¶å™?
esp_err_t web_controller_stop(web_controller_handle_t handle)
{
    if (!handle) {
        return ESP_ERR_INVALID_ARG;
    }
    
    struct web_controller *controller = (struct web_controller *)handle;
    
    // åœæ­¢HTTPæœåŠ¡å™?
    if (controller->server) {
        httpd_stop(controller->server);
    }
    
    // åœæ­¢WiFi
    esp_wifi_stop();
    esp_wifi_deinit();
    
    // é‡Šæ”¾èµ„æº
    if (controller->html_content) {
        free(controller->html_content);
    }
    
    if (controller->json_mutex) {
        vSemaphoreDelete(controller->json_mutex);
    }
    
    if (controller->wifi_event_group) {
        vEventGroupDelete(controller->wifi_event_group);
    }
    
    free(controller);
    
    return ESP_OK;
}

// è·å–IPåœ°å€
const char *web_controller_get_ip(web_controller_handle_t handle)
{
    if (!handle) {
        return NULL;
    }
    
    struct web_controller *controller = (struct web_controller *)handle;
    return controller->ip_addr;
}

}


